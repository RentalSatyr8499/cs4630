ttt1.exe: I used Ghidra. I searched for strings and found "Enter password:" in .rodata. Using the XREF, I jumped from there to the password check function. From the password check function, I found the game entry point. Then, I went to the main routine (Ghidra gives you the entry point of the whole program), and patched the password check function's wrapper function to call the game entry point instead of the password check.

ttt2.exe: I searched for the string "Enter password:" and the XREF to find the switch case associated with the password check in the flattened program. Then I patched that case by deleting the print statement and deleting the jump to the password check function (which was fortunately still a function). It took me a while to figure out that I needed to keep the self-referential call back into the same routine, though.

ttt3.exe: I identified the decryptor in Ghidra using the entry point Ghidra found. Then I set a breakpoint at the end of the decryptor in gdb. After running to that point, I dumped 0x4010 bytes worth of binary into a .bin file starting from .init. I imported this file to Ghidra using "Add to program". Then I re-ran the Ghidra analysis tool to decompile the decrypted code. Then I deleted the password guard in the same way that I did with ttt1.exe.

ALSO, you can't export executables that have been Frankensteined together -- Ghidra got mad at me for having binary that came from two sources (the original .exe and the .bin I created), saying "Warning: Only bytes from primary (first) source will be exported". Ghidra's copy and paste bytes function is very very bummy, so I couldn't write the bytes into a one-file Ghidra project either. I had to write a C program to patch the bytes in manually. It might help to put this in the hints for this assignment