* I used "objdump -d --file-offsets [target]", which showed the file offset of each symbol. I added that to the instruction offset from the symbol (found by subtracting virtual addresses). 
    * As for how I chose the location, I just saw the symbol "InitApplication" and went to the end of that routine (matched assignment specs).
    * For target1, I scrolled around "objdump -d" until I saw a no-op island. For target2 and target3a, I used a cavity revealed by "readelf -l" that came at the end of the r-x segment. I found that you can actually read cavities using "hexdump -C -s {start offset}".
* I copied the virus payload (in assembly) from the assignment instructions. Then I compiled it with "gcc -c file.S". Then I inspected it with objdump.
* It would parse the ELF header to find where the executable segment ends. Then, if it finds that there's slack space between the executable segment and the next segment, it chooses that "cavity" as the location for the payload. Then, it would need to find a place to insert the tricky jump. If there's no particular target (like "right after initializing application"), then it would simply find the first "pushq $value, ret", save those bytes, then overwrite them. Finally (as infect3a.c does) it injects the saved bytes back into where the payload is to restore original program functionality.